//! Parsing errors

use crate::{local::*, utils::diff::*};

use std::collections::HashMap;

use sync::PoisonError;

use allwhat::ErrorGroup;
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use thiserror::Error;

pub type Result<T> = core::result::Result<T, GraphtError>;

/// A structure for capturing errors generated by Grapht
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub struct GraphtError {
  /// The general error genus
  kind: Kind,

  /// An error message geared toward an end user
  comment: Option<String>,

  /// A developer based context object
  /// FIXME: This should be a downcastable object, not a string, usable for both rollbacks and
  ///   debugging
  context: Option<String>,
}

impl std::error::Error for GraphtError {}

impl GraphtError {
  /// Get the kind of error (for matching)
  pub fn kind(&self) -> &Kind {
    &self.kind
  }

  /// Quick matcher for determining the general kind of error
  pub fn is(&self, kind: Kind) -> bool {
    self.kind == kind
  }

  /// A shortcut to asking if is a DuplicateKey error
  pub fn is_dupe(&self) -> bool {
    self.is(Kind::DuplicateKey)
  }

  pub fn comment(mut self, comment: String) -> GraphtError {
    self.comment = Some(comment);
    self
  }

  pub fn context(mut self, context: String) -> GraphtError {
    self.context = Some(context);
    self
  }
}

#[derive(Debug, Error, Serialize, Deserialize, Clone)]
pub enum Kind {
  //-- Generic Errors
  #[error("Multiple errors have been found")]
  #[serde(
    serialize_with = "Kind::serialize_error_list",
    deserialize_with = "Kind::deserialize_error_list"
  )]
  ErrorList(ErrorGroup),

  #[error("General error caught")]
  General,

  #[error("An item with the same Id already exists")]
  DuplicateKey,

  #[error("A lookup returned no values")]
  NotFound,

  #[error("An optional value that is set to none when it is called")]
  NotSet,

  #[error("A lookup found multiple matches")]
  MultipleMatches,

  #[error("A function that has not yet been implemented that still needs to gracefully fail")]
  NotImplemented,

  #[error("Matcher Compilation Error")]
  CompileError,

  #[error("Ambiguous match: cannot decide between values. Use First combinator to fix")]
  AmbiguousMatch,

  #[error("Runtime parsing error")]
  ParsingError,

  #[error("An error found in the grammar definition")]
  GrammarError,

  #[error("Problem matching grammar version")]
  VersionError,

  #[error("Received an item that doesn't match the context used")]
  InvalidItem,

  #[error("Received an unexpected/incorrect encapsulating variant")]
  TypeMismatch,

  #[error("Could not convert between data types")]
  ConversionError,

  #[error("Could not serialize the given object")]
  SerializationError,

  #[error("Error generated from within Grapht")]
  GraphtError,

  #[error("Error caught from Redis Graph")]
  RedisError,

  //-- IO Errors
  #[error("IO Error")]
  Io,

  #[error("An expected file/path could not be found locally")]
  FileNotFound,

  #[error("XML Parsing Error")]
  XmlError,

  #[error("The data structure cannot be trusted any more and requires manual intervention")]
  PoisonError,
}

impl Kind {
  pub(crate) fn serialize_error_list<S>(
    _value: &ErrorGroup,
    _ser: S,
  ) -> core::result::Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    todo!("Serialize ErrorList")
  }

  pub(crate) fn deserialize_error_list<'de, D>(_de: D) -> core::result::Result<ErrorGroup, D::Error>
  where
    D: Deserializer<'de>,
  {
    todo!("Deserialize ErrorList")
  }
}

impl PartialEq for Kind {
  fn eq(&self, other: &Self) -> bool {
    match (self, other) {
      (Self::ErrorList(_), Self::ErrorList(_)) => todo!("Figure out how to match error lists"),
      _ => core::mem::discriminant(self) == core::mem::discriminant(other),
    }
  }
}

impl Diff for Kind {
  fn diff(&self, rhs: &Self, name: Option<&str>) -> Difference {
    if *self != *rhs {
      Difference::Node(
        Some((format!("{}", self), format!("{}", rhs))),
        HashMap::new(),
      )
    } else {
      Difference::Empty
    }
    .opt_tag(name)
  }
}

impl Display for GraphtError {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let comment = match &self.comment {
      Some(x) => format!("\nt{}", x),
      None => String::new(),
    };

    let context = match &self.context {
      Some(x) => format!("\nt{}", x),
      None => String::new(),
    };

    write!(f, "{}{}{}", self.kind, comment, context)
  }
}

impl GraphtError {
  pub fn new(kind: Kind) -> GraphtError {
    GraphtError {
      kind,
      comment: None,
      context: None,
    }
  }
}

unsafe impl Sync for GraphtError {}

unsafe impl Send for GraphtError {}

impl Diff for GraphtError {
  fn diff(&self, rhs: &Self, name: Option<&str>) -> Difference {
    let mut diff = Difference::new();
    diff += self.kind.diff(&rhs.kind, Some("kind"));
    diff += self.comment.diff(&rhs.comment, Some("comment"));
    diff += self.context.diff(&rhs.context, Some("context"));

    match name {
      Some(name) => {
        let mut result = Difference::Empty;
        result.merge(diff, Some(vec![name.to_string()]));
        result
      }
      None => diff,
    }
  }
}

pub trait Comment<T, E> {
  fn comment<C>(self, comment: C) -> Result<T>
  where
    C: Into<String> + Diff;
  fn context<C>(self, ctx: C) -> Result<T>
  where
    C: Display + Debug + Sync + Send + 'static;
}

impl<T, E> Comment<T, E> for Result<T>
where
  E: Into<GraphtError>,
{
  fn comment<C>(self, comment: C) -> Result<T>
  where
    C: Into<String>,
  {
    match self {
      Ok(x) => Ok(x),
      Err(err) => {
        // Convert into a fhl error, if possible
        let mut err: GraphtError = err.into();
        err.comment = Some(comment.into());
        Err(err)
      }
    }
  }

  fn context<C>(self, ctx: C) -> Result<T>
  where
    C: Display + Debug + Sync + Send + 'static,
  {
    match self {
      Ok(x) => Ok(x),
      Err(err) => {
        // Convert into a fhl error, if possible
        let mut err: GraphtError = err.into();
        err.context = Some(format!("{:#?}", ctx));
        Err(err)
      }
    }
  }
}

impl<T> From<PoisonError<T>> for GraphtError
where
  T: Debug,
{
  fn from(err: PoisonError<T>) -> Self {
    GraphtError {
      kind: Kind::PoisonError,
      comment: Some(format!("{:#?}", err)),
      context: None,
    }
  }
}

impl From<ErrorGroup> for GraphtError {
  fn from(grp: ErrorGroup) -> Self {
    GraphtError {
      kind: Kind::ErrorList(grp),
      comment: None,
      context: None,
    }
  }
}

impl From<xmlparser::Error> for GraphtError {
  fn from(err: xmlparser::Error) -> GraphtError {
    GraphtError {
      kind: Kind::XmlError,
      comment: Some(format!("{:#?}", err)),
      context: None,
    }
  }
}

impl From<std::io::Error> for GraphtError {
  fn from(err: std::io::Error) -> GraphtError {
    GraphtError {
      kind: Kind::Io,
      comment: None,
      context: Some(format!("{:#?}", err)),
    }
  }
}

// impl From<redis::RedisError> for GraphtError {
//   fn from(err: redis::RedisError) -> GraphtError {
//     GraphtError {
//       kind: Kind::RedisError,
//       comment: None,
//       context: Some(format!("{:#?}", err)),
//     }
//   }
// }

impl From<std::str::Utf8Error> for GraphtError {
  fn from(err: std::str::Utf8Error) -> GraphtError {
    GraphtError {
      kind: Kind::ParsingError,
      comment: None,
      context: Some(format!("Could not convert bytes to a string: {:#?}", err)),
    }
  }
}

/// Simple macro to create an FHL error
#[macro_export]
macro_rules! err {
  (@comment $($comment:expr),+) => {
    format!($($comment),+)
  };
  (@comment $comment:expr) => {
    $comment.to_string()
  };
  ($kind:ident $(, $($comment:expr),+)?) => {
    GraphtError::new(Kind::$kind)
      $(.comment(err!(@comment $($comment),+)))?
  };
}

#[macro_export]
macro_rules! err_into {
  (@comment $($comment:expr),+) => {
    format!($($comment),+)
  };
  (@comment $comment:expr) => {
    $comment.to_string()
  };
  ($res:expr $(, $($comment:expr),+)?) => {
    match $res {
      Ok(x) => Ok(x),
      Err(err) =>
        Err(err.into())
          $(.comment::<String>(err_into!(@comment $($comment),+).into()))?,
    }
  };
}
